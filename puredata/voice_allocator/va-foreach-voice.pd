#N canvas 0 49 1920 1009 12;
#X obj -30 -30 preset_hub k12 1 %hidden%;
#X obj 100 400 pointer;
#X msg 100 370 traverse pd-va_data \, next;
#X text 110 350 ---- Get va_state instance ----;
#X text 110 510 ---- Loop over all voices ---;
#X obj 100 590 - 1;
#X obj 100 620 until;
#X obj 100 660 f;
#X obj 140 660 + 1;
#X text 160 400 va_state pointer;
#X text 270 690 Output: va_voice pointer;
#X obj 100 300 inlet;
#X obj 100 430 trigger p p;
#X obj 100 760 outlet;
#X text 110 740 ---- Output va_voice pointer ----;
#X text 400 370 This gets the va_state instance \, because it is the
only scalar in the va_data canvas., f 33;
#X obj 400 540 inlet;
#X obj 100 560 trigger f b;
#X msg 160 620 0;
#X obj 400 570 bang;
#X obj 200 460 s \$0-va_main-pointer;
#X obj 100 530 get va_main polyphony;
#X obj 280 660 r \$0-va_main-pointer;
#X obj 100 690 element va_main voices;
#X text 10 10 Another small abstraction to simplify the implementation
of the voice allocator. This time iterating over all va_voice instances
\, which is needed whenever the voice allocator receives an event that
it must handle., f 61;
#X text 10 90 Send a bang to the first inlet to start the iteration.
The outlet will output the va_voice pointers one after another.;
#X text 10 140 Send a bang to the second inlet to end the iteration
early.;
#X text 10 170 \$1 must be \$0 of the voice allocator.;
#X connect 1 0 12 0;
#X connect 2 0 1 0;
#X connect 5 0 6 0;
#X connect 6 0 7 0;
#X connect 7 0 8 0;
#X connect 7 0 23 0;
#X connect 8 0 7 1;
#X connect 11 0 2 0;
#X connect 12 0 21 0;
#X connect 12 1 20 0;
#X connect 16 0 19 0;
#X connect 17 0 5 0;
#X connect 17 1 18 0;
#X connect 18 0 7 0;
#X connect 19 0 6 1;
#X connect 21 0 17 0;
#X connect 22 0 23 1;
#X connect 23 0 13 0;
